[toc]

## 概述

前端使用到的技术主要有：

1. WebSocket 即时通信
2. Web Audio API 录音与播放
3. Canvas 绘图
4. 富文本编辑技术

应用的 Web 页面一共分三部分：

- 登录/注册页：`/auth`
- 教师端：`/teac`
- 学生端：`/stud`

其中，`/auth` 有 `signin` 和 `signup` 两个页面，大多数逻辑可以复用；`/stud` 和 `/teac` 布局相同，部分组件也可复用。

## 鉴权

页面主要由背景、登录框和[系统消息](#系统消息)三部分组成。登录框定位使用 `transform` 属性，垂直方向上始终居中显示，水平方向上放置右侧，与背景形成偏倚关系；内部使用 Grid 布局，保证弹性伸缩。添加外阴影和半透明效果，显现出层次感。

点击“登录”或“注册”时将从上到下依次校验每一个字段值的合法性，不满足则终止提交表单而触发系统消息，同时刷新验证码，为方便用户，校验失败将自动清除验证码以重新填写。验证码输入框存在监听函数，方便用户使用回车直接提交而避免使用鼠标，类似的设计还有聊天输入框，可根据用户喜好，使用鼠标点击、<kbd>Enter</kbd> 以及 <kbd>Shift</kbd> + <kbd>Enter</kbd> 发送信息。

```js
$("#input").on((e) => {
    if (e.keyCode === 13) {
        // 处理事件
    }
})
```

使用 AJAX 与后端交互，登陆成功后使用 `localStorage.setItem()` 在本地存储用户信息，并跳转到主页面。因 localStorage 存储的持久性，在新页面初始化时将信息取出。退出登录时使用 `localStorage.removeItem()` 移除存储的信息，然后跳转到登录页。

## 同构部分
### 系统消息

消息一般分为 *通知*、*警告*、*错误*三级，设计为蓝、黄、红三种颜色，在侧边出现，所有内容之前，若干秒后自动消失。使用一个消息容器装载各种消息，该标签独立于文档流，在所有元素的上方（`z-index` 设为 `999`），使用 CSS 类来组织样式。抽离出一个函数 `sendInform()` 以代替 `console.log()` 或 `alert()` 等用户体验较差的通知方式。

### 页面布局

讨论区以及笔记区/功能区，使用 MDUI 的导航组件进行切换，节约空间，并作为侧栏，将大部分空间留给演示区/展示区。

对于教师端，演示区主要有一个加载 slide 的 `<canvas>` 元素和一个绘制批注的 `<canvas>` 元素；Canvas 只允许使用代码作图而无法输入，所以文本输入需要使用一个隐藏的 `<textarea>` 元素作为代理；同时，保存批注使用 Base64 字符串代表的图片，因此加载时需要一个隐藏的 `<img>` 元素作为代理；另一方面，未开课和课程结束的信息提示也显示在此，需要一个展示层。因此，使用绝对定位，按照“子绝父相”的原则，层叠了如下元素：

1. 提示信息
2. 批注 canvas
3. 文本工具代理 textarea
4. 幻灯片 canvas
5. 加载图片代理 img

对于学生端，展示区主要有加载 slide 和批注的两个 `img` 元素；还有与教师端相同的展示层；另外，课程期间，可进行题目问答，在展示区交互，需要有问答层；课程结束后，学生可选择观看视频，需要有一个播放层。因此学生端这块区域层叠了以下元素：

1. 视频
2. 问答
3. 提示信息
4. 批注 img
5. 幻灯片 img

### 即时通信

即时通信使用 WebSocket 协议，分两条线路：二进制形式的语音通道和字符形式的课程与聊天消息通道，除此之外通知类消息也以文本形式经过字符消息通道。

JSON 型的字符消息较多，所以封装了一个函数 `sendText()`，转换 JS 对象为 JSON 字符以发送 WS 消息：

```js
const sendText = (msg) => {
	if (user.chatConnect.ws) {
		user.chatConnect.sendMessage(JSON.stringify(msg));
	} else {
		sendInform("已掉线，正在帮您重连", "error");
		user.chatConnect.connect();
		setTimeout(() => sendText(msg), 2000);
    }
    // 具备提醒和自动断线重连的功能
};
```

收到字符型消息时，到达 `handle-*` 函数前经过 `switch ... case` 的选择处理：

```js
const handler = (msg) => {
    message = JSON.parse(msg.data);

    switch (message.type) {
        case wsType.enter:
            break;
        case wsType.leave:
            break;
        // ...
        default:
            break;
    }
}
```

#### 语音

采集声音使用 WebRTC 的 `mediaDevices.getUserMedia()`。

```js
navigator.mediaDevices.getUserMedia(constraints)
    .then(function(stream) {
        /* 使用 stream stream */
    })
    .catch(function(err) {
        /* 处理 error */
    });
```

语音通信使用流的模型，将数据存放在缓冲区，间隔若干时间后取出。完成这一目的，先要创建对应的音频模块，将获得的媒体流保存到缓冲区，然后创建音频终端，不断取出数据。为方便复用，创建了一个处理数据的 `SAudioData` 类和一个管理音频的 `SRecorder` 类。

#### 聊天

教师端和学生端收发消息的逻辑略有不同，但聊天和出入教室逻辑相同，因此抽离成函数。

- 每次进入教室时，后端需要广播更新在线人员和通告该成员的信息，使用 `recvNotify()` 和 `handleOnline()` 接收系统消息以及处理更新
- 每次退出教室同上
- 发送消息 `textSubmit()`
- 收到消息 `recvText()`

### 聊天面板

主要有两类内容，系统消息和对话消息，系统消息主要提示成员进入和成员离开，身份为教师则标为橙黄色，视觉突出；对话消息又有本人消息（出现在右侧）和他人消息（出现在左侧），位置和颜色的不同从视觉上区分消息的关系。

实现上，使用三种 CSS 类：`teac`、`self` 和 `notify`，组装好消息体后使用 DOM 操作 `append()` 到容器，并且操作滚动条到底部。

### 成员列表

仿照 QQ 等即时通信软件，将成员列表收入二级菜单，本页面放在消息窗口的顶部，设置一个下拉列表。下拉使用 MUDI 的 `mdui-collapse` 组件。

为了视觉上的层次感，加入了毛玻璃效果，将背景虚化。采用 `backdrop-filter`（Chromium）和 `-moz-element()` 函数（Firefox），综合下来，在 Chromium 内核浏览器上视觉效果最佳。成员使用 MDUI 提供的卡片 `mdui-chip`，并且加入首字母以增加内容。布局采用 flex 横向流动，保证列表始终居中对齐。

列表的数据采用**防抖**的策略。页面上默认存有 10 个列表项，但只显示在线成员的项，某次更新到大于 10 的成员，则再一次性创建 10 个列表项，并且每次更新只更改值而不操作 DOM，将操作时间降低到 1ms 以内，避免开课前人员出入造成频繁的 DOM 操作。

## 教师端

与学生端最显著的区别就是演示区支持批注，有一个工具栏。另外功能区有一系列上课的操作按钮。

### 批注

首先，批注使用 Canvas API 实现，每次下笔（按下鼠标）后移动（移动鼠标 `mouseover`），将实时监听鼠标位置，根据鼠标位置即时绘制，由此产生动态效果。圆、矩形、三角形等采用公式计算得出。各种工具函数使用 `toolBox` 对象维护，使用 `lineStyle` 数组标识。绘图的上下文环境使用 `store` 全局对象保存。

关于历史记录，编写了一个 `canvasRing` 类，每次操作 Canvas，使用该类的方法代为处理，并且保存快照。经过多次尝试和检测，使用 JS 数组的 `slice()` 方法创建新数组效率极高，所以使用原生数组作为保存历史记录的数据结构，到达记录数的阈值后截取之，原数组则由引擎自动回收。一旦撤销后进行了修改，则记录应从当前开始，所以重做功能的实现需要用到一个指针 `ringGap` 用来指示最新的更改。取色器使用第三方库 [jscolor.js](http://jscolor.com)，指定节点后初始化，将添加事件和渲染面板。

### 幻灯片

幻灯片使用 PDF 格式，这里用到了 [PDF.js](https://cdn.bootcss.com/pdf.js/2.4.456/pdf.min.js) 第三方库加载 PDF。

```js
let fr = new FileReader();
fr.readAsArrayBuffer($("#load")[0].files[0]);
fr.onload = () => {
    pdfjsLib.getDocument(fr.result).promise
        .then((pdf) => {})
}
```

首先使用 FileReader 对象读取文件二进制数据，在 `onload` 事件添加回调。每次翻页都需要调用 `pdfContent.getPage(page)`，因此封装了一个函数 `gotoPage()`，作为一切页面切换的终端，在这之上又封装了跳转页和翻页。跳转页面响应键盘事件，回车即跳转；首页/末页将传入页码，而翻页则不是，因此，参数有布尔值和数字两种，`turnPage()` 函数做了校验和跳转。

每次切换页面，背后进行了大量操作。

第一步，先保存当前批注，如果有修改的话。使用 `isModified` 变量来标识批注是否有修改，每当新页面使用了绘图工具（`mousedown`），就置为 `true`，

有保存就有加载，该函数的最后一部分就是用于加载批注。批注和 Slide 分层的设计使管理清晰，但操作会更加复杂，两者的页面是一一对应的，每当加载了新的 Slide，就要加载对应的批注，假如批注未保存过，那么内容就是 `undefined`，此时直接加载即可；否则，先使用 `asyncNote()` 函数同步到学生端以减少网络延迟，再加载到 `<img>` 代理，然后使用 `drawImage()` 绘制到 `<canvas>` 元素。一旦切换页面，就认定是保留批注，因此再切换回来，应该保留原来的批注。切换页面后历史记录也要切换，那么同时每一页的最先一步永远是初始状态，所以，每次加载完批注（不管存不存在）都会在历史记录中建立一份快照 `drawingRing.init()`。

中间部分就是加载 Slide，每个幻灯片大小不一，但屏幕展示区域有限，所以要使用最佳大小。计算最佳大小的算法是，从 `1` 的缩放比例开始，递增 `0.1`，直到宽高分别为 `960` 和 `540`，但这样会存在问题，刚小于的值比如 `959`，不满足条件，再扩大比例，导致画面失衡；再如，分辨率不是按照 16:9，而是某个参数较大，画面同样会失控。基于这样的考虑，引入了一个缓冲值，（以 `40` 为例）在 `919` 的时候依旧可以增加 `0.1` 的缩放，但计算得到的新值仍在预期的范围。这个值便是最佳缩放比例。使用同一份幻灯片，这个值不需要重新计算，所以需要判断条件；另一方面，该比例值就按得到的宽高也属于不变量，同样要区分是否为第一次加载，所以引入了 `isFirst` 局部变量。在加载页面后，使用 `asyncSlide()` 将页面同步到学生端，但 PDF 的 `render()` 方法具有异步性但没有提供回调，此处使用了定时器手动异步的方式，等待加载完毕再抓取数据发送。

开课的逻辑是加载幻灯片，填写好课程名后才能开课，所以“开始课程”按钮需要做一个校验，如果没有填写课程名则提示并且自动聚焦到输入框，如果课程名为空，那么加载课件会自动使用文件名填写。输入框的内容有可编辑和不可编辑两种状态，可通过按钮开关。开课以服务器返回的结果作为依据，当 WebSocket 接收到开课信息，会启动教师端和学生端的计时器以记录上课时长。

上课结束也以服务器返回的数据为依据，上课时长使用服务器时间。教师端会收到学生的听课记录，在本地处理为 CSV 表格并导出。

上课过程中，除正常聊天外，教师可以发布题目。题目以讨论题为主，编辑时需要给出参考答案。一旦发布，在预留时间内不能再次发布，避免题目混乱。学生端在收到题目时，会预留 20 秒读题，然后再计预留的时间。在预留时间内，未填写内容而点击提交将中断而给出提示；预留时间结束时将自动提交 ` ` 字符。提交后将返回参考答案，展示两分钟后自动关闭，也可选择手动关闭。

## 学生端

学生端的笔记区提供一个富文本编辑器，使用 [wangEditor.js](http://www.wangeditor.com/) 库，在页面加载后执行初始化。在侧边栏的布局场景下，原生提供的样式无法满足，所以在源码修改了部分样式，按照上下布局，约束在面板内。又引入一个保存按钮，用于保存笔记。同样，假设内容为空则不保存而进行提示。

```js
const save = () => {
	let time = new Date();
	saveFile(
		new Blob([html], { type: "text/plain" }),
		"笔记_" +
			time.getMonth() +
			"月" +
			time.getDate() +
			"日_" +
			time.getHours() +
			"_" +
			time.getSeconds() +
			".html"
	);
}
```

笔记使用 HTML 富文本，因此保存时提取编辑器节点下的内容（`html`），然后转换成字符形式的二进制对象，为确保文件的相对唯一性，保存时名称默认使用当前的时间。

其中保存函数如下：

```js
const saveFile = (blob, name) => {
	let blobUrl = window.URL.createObjectURL(blob);
	let proxy = $("a#download")[0];
	proxy.href = blobUrl;
	proxy.download = name;
	proxy.click();
	window.URL.revokeObjectURL(exportBlob);
};
```

借助一个隐藏的 `<a>` 标签，将二进制转换为 Blob URL，然后使用 JS 模拟鼠标点击，可以产生自动弹出下载框的效果。